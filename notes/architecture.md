
Inheritance in ViewModels
I had been struggling in my own thought about how to be DRY (Don't Repeat Yourself) with ViewModels
because I have similar but different views for user Registration and for Admins to create or edit users
I tried to use the same ViewModel across these scenarios to be DRY
but things get messy when something on the viewmodel is required in some view but not shown or needed in another view
googled a bit and found this:
http://stackoverflow.com/questions/6954102/asp-net-mvc-architecture-viewmodel-by-composition-inheritance-or-duplication
http://stevemichelotti.com/aspnet-mvc-view-model-patterns/
https://lostechies.com/jimmybogard/2009/06/30/how-we-do-mvc-view-models/
and I guess I have to agree it is better to have that kind of duplication as opposed to using larger viewmodels than is required by the view
had thought about trying to use inheritance with viewmodels inherting from each other to add fields
it seesm there are some issues with kind of approach for client side validation though I have not tested to confirm if those issues stillexist in 
aspnetcore rc2, but I suspect they do

still some challenges remain for allowing people to do things in flexible ways
for example, if a site is configured to login by email, then we still need a unique login name for the user, in case this site setting is ever changed.
On the admin side when creating a user we will always show the login input and use remote validation to ensure no duplicatesd are entered there.
However different users of cloudscribe may or may not want to show LoginName input on the registration page, if not using it why show it, it can be autogenerated.
Similarly DisplayName is needed but can be auto generated from the email or it can be shown and the user can choose what to use for their public display name, ie in forums in the header greeting etc.
So we have some things we want to conditionally require or based on the customer wishes for the given web project.
I have done some work with custom validators that support conditional configuration based on other model properties.
Because for example the [Required] attribute is not conditional, if it is on the viewmodel then it is required.
Instead we need something like [RequiredWhen("OtherBoolProperty", ErrorMessage = "error message here")]
where the OtherBoolProperty is just another property on the viewmodel that determines if the required attribute should be activated
this can be set from the controller based on configuration or site settings

http://blog.ploeh.dk/2014/08/11/cqs-versus-server-generated-ids/

http://blog.ploeh.dk/2016/05/06/cqs-and-server-generated-entity-ids/

https://topherlandry.wordpress.com/2014/09/08/using-exceptions-to-break-command-query-separation/

I had some doubts about commands returning only void, to me it seemed reasonable for every command to return a bool
indicating success or failure of the command, but this article set me straight
http://blog.iannelson.systems/back-to-basics-on-the-use-and-abuse-of-the-humble-boolean/

http://rob.conery.io/2014/03/04/repositories-and-unitofwork-are-not-a-good-idea/

https://blog.rendle.io/do-one-thing-and-do-it-well/

http://joeduffyblog.com/2010/09/06/the-premature-optimization-is-evil-myth/


http://shazwazza.com/post/custom-assembly-loading-with-aspnet-core/

http://blog.ploeh.dk/2011/04/27/Providerisnotapattern/
